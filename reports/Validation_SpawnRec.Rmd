---
title: "Capacity Comparisons: QRF and Spawner-Recruit Curves"
author:
  - name: Kevin See
    affiliation: biomark
    email: kevin.see@merck.com
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  bookdown::html_document2:
    theme: simplex
    toc: yes
    toc_depth: 3
    toc_float: yes
    fig_height: 8
    fig_width: 8
    pandoc_args:
    - --lua-filter=templates/scholarly-metadata.lua
    - --lua-filter=templates/author-info-blocks.lua
    - --lua-filter=templates/pagebreak.lua
  bookdown::pdf_document2:
    pandoc_args:
    - --lua-filter=templates/scholarly-metadata.lua
    - --lua-filter=templates/author-info-blocks2.lua
    - --lua-filter=templates/pagebreak.lua
    fig_height: 6
    fig_width: 8
    includes:
      in_header: "templates/header_ABS.tex"
  bookdown::word_document2: 
    fig_caption: yes
    fig_height: 4
    fig_width: 7
    toc: yes
    pandoc_args:
    - --lua-filter=templates/scholarly-metadata.lua
    - --lua-filter=templates/author-info-blocks.lua
    - --lua-filter=templates/pagebreak.lua
    reference_docx: "templates/ReportTemplate.docx"
institute:
- biomark: Biomark, Inc.
csl: "templates/american-fisheries-society.csl"
# bibliography: references.bib
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
# setwd('reports')
# load knitr for markdown
library(knitr)
knitr::opts_chunk$set(echo=FALSE, 
                      warning=FALSE,
                      # error = FALSE,
                      message=FALSE)
#options(tinytex.verbose = TRUE)
options(knitr.kable.NA = '-')
options(knitr.table.format = "pandoc")

library(kableExtra)
```

```{r}
# load needed packages
library(tidyverse)
library(sf)
library(QRFcapacity)
library(janitor)
library(ggpubr)

theme_set(theme_bw())
```

# Introduction

We can validate Chinook summer parr estimates of capacity with spawner-recruit data from a number of watersheds. Morgan Bond at the Northwest Fisheries Science Center helped compile this data set with help from a variety of agencies and organizations including WDFW, ODFW, IDFG, USFS, BioAnalysts, Biomark, Nez Perce, etc. Most of the parr (recruits) data comes from rotary screw traps (with the exception of the Chiwawa, where snorkel surveys of parr were used to estimate parr directly). Estimates of parr-to-presmolt and parr-to-smolt survival were used to transform estimates of fall and spring emigrants to estimates of equivalent summer parr. Spawner estimates came from either redd counts or direct estimates of spawners. 

From this dataset, we fit several spawner-recruit curves to each location, including Beverton-Holt, Ricker and hockey stick. The data at some locations led to some curves not fitting (no model convergence). Each of these spawner-recruit curves also generated an estimate of summer parr carrying capacity, which we can then compare to QRF estimates. We want to emphasize that the data for the spawner-recruit curves and the QRF estimates are completely independent, and therefore provide a good way to validate the QRF estimates of carrying capacity.

```{r trap-polygons}
# read in trap polygons
trap_poly = read_sf('../data/raw/spawn_rec/trap_regions.shp') %>%
  st_transform(crs = 5070) %>%
  select(-Id)

# which QRF model to use?
mod_choice = c('juv_summer',
               'juv_summer_dash',
               'redds')[2]
```

```{r cap-max, eval = F}
load(paste0('../output/modelFits/qrf_', mod_choice, '.rda'))
# define max capacity based on observed densities
cap_max = qrf_mod_df %>%
  group_by(Species) %>%
  summarise(quant95 = quantile(fish_dens, 0.95),
            quant98 = quantile(fish_dens, 0.98),
            quant99 = quantile(fish_dens, 0.99),
            quant995 = quantile(fish_dens, 0.995),
            quant100 = quantile(fish_dens, 1)) %>%
  filter(Species == 'Chinook') %>%
  pull(quant100)
```


```{r rch-200m-cap, eval = T}
# read in capacity estimates and create a shapefile
load(paste0('../output/modelFits/extrap_200rch_', mod_choice, '.rda'))
in_covar_range_df = model_svy_df$pred_all_rchs[[1]] %>%
  select(UniqueID, in_covar_range)
rm(mod_data_weights, model_svy_df, extrap_covars)

data("rch_200")

rch_200_cap = rch_200 %>%
  filter(chnk) %>%
  select(UniqueID, GNIS_Name, reach_leng:HUC8_code, 
         chnk, chnk_use, chnk_ESU_DPS:chnk_NWR_NAME) %>%
  left_join(all_preds) %>%
  mutate(chnk_tot = chnk_per_m * reach_leng,
         chnk_tot_se = chnk_per_m_se * reach_leng) %>%
  left_join(in_covar_range_df) %>%
  # filter(in_covar_range) %>%
  st_transform(st_crs(trap_poly)) %>%
  select(everything(), geometry)

# rch_200_cap %>%
#   st_drop_geometry() %>%
#   xtabs(~ (chnk_per_m > cap_max) + in_covar_range, .)
# 
# rch_200_cap %<>%
#   mutate(chnk_per_m_se = if_else(chnk_per_m > cap_max, 
#                                  as.numeric(NA), chnk_per_m_se),
#          chnk_per_m = if_else(chnk_per_m > cap_max, 
#                               cap_max, chnk_per_m))


rm(rch_200, all_preds)

qrf_caps = trap_poly %>%
  st_join(rch_200_cap) %>%
  mutate_at(vars(chnk_ESU_DPS, chnk_MPG, chnk_NWR_NAME),
            list(fct_explicit_na)) %>%
  group_by(chnk_ESU_DPS, chnk_MPG, trap_name) %>%
  summarise(n_rch = n_distinct(UniqueID),
            tot_lgth = sum(reach_leng, na.rm = T),
            cap = sum(chnk_tot, na.rm = T),
            cap_se = mean(chnk_per_m_se, na.rm = T) * tot_lgth) %>%
            # cap_se = sqrt(sum(chnk_tot_se^2))) %>%
  ungroup() %>%
  mutate(cap_cv = cap_se / cap) %>%
  rename(Trap = trap_name) %>%
  mutate(Trap = recode(Trap,
                       'Minam R.' = 'Minam River',
                       'Entiat R.' = 'Entiat River',
                       'Crooked Fork Creek' = 'Crooked Fork',
                       'Upper Grande Ronde R.' ='Upper Grande Ronde River',
                       'Toucannon R.' = 'Tucannon River',
                       'Pahsimeroi' = 'Pahsimeroi River',
                       'Hood R.' = 'Hood River',
                       'John Day Middle Fork' = 'Middle Fork John Day',
                       'Upper Salmon River' = 'Upper Salmon River Chinook',
                       'John Day Upper Mainstem' = 'Upper Mainstem John Day',
                       'East Fork Salmon' = 'East Fork Salmon River',
                       'Lostine R.' = 'Lostine River'))
```

```{r master-sample-pts-cap, eval = T}
# read in capacity estimates and create a shapefile
load(paste0('../output/modelFits/extrap_mastPts_', mod_choice, '.rda'))

data("gaa")
data("chnk_domain")

capacity_pts = all_preds %>%
  left_join(gaa %>%
              select(Site, Lon, Lat)) %>%
  filter(!is.na(Lon)) %>%
  st_as_sf(coords = c('Lon', 'Lat'),
           crs = 4326) %>%
  st_transform(st_crs(trap_poly))

qrf_caps2 = trap_poly %>%  
  st_join(capacity_pts) %>%
  group_by(trap_name) %>%
  summarise(n_pts = n_distinct(Site),
            avg_cap = mean(chnk_per_m, na.rm = T),
            avg_cap_se = mean(chnk_per_m_se, na.rm = T)) %>%
  ungroup() %>%
  left_join(trap_poly %>%
              st_join(chnk_domain %>%
                        mutate(reach_leng = st_length(.))) %>%
              mutate_at(vars(chnk_ESU_DPS = ESU_DPS, 
                             chnk_MPG = MPG),
                        list(fct_explicit_na)) %>%
              group_by(chnk_ESU_DPS, chnk_MPG, trap_name) %>%
              summarise(tot_lgth = sum(reach_leng)) %>%
              ungroup() %>%
              st_drop_geometry()) %>%
  group_by(chnk_ESU_DPS, chnk_MPG, trap_name, n_pts, tot_lgth) %>%
  summarise(cap = avg_cap * as.numeric(tot_lgth),
            cap_se = avg_cap_se * as.numeric(tot_lgth),
            cap_cv = cap_se / cap) %>%
  ungroup() %>%
  rename(Trap = trap_name) %>%
  mutate(Trap = recode(Trap,
                       'Minam R.' = 'Minam River',
                       'Entiat R.' = 'Entiat River',
                       'Crooked Fork Creek' = 'Crooked Fork',
                       'Upper Grande Ronde R.' ='Upper Grande Ronde River',
                       'Toucannon R.' = 'Tucannon River',
                       'Pahsimeroi' = 'Pahsimeroi River',
                       'Hood R.' = 'Hood River',
                       'John Day Middle Fork' = 'Middle Fork John Day',
                       'Upper Salmon River' = 'Upper Salmon River Chinook',
                       'John Day Upper Mainstem' = 'Upper Mainstem John Day',
                       'East Fork Salmon' = 'East Fork Salmon River',
                       'Lostine R.' = 'Lostine River')) %>%
  select(starts_with('chnk'),
         Trap,
         everything(),
         geometry) %>%
  filter(n_pts > 1)

```

```{r pts-rch-comparison, eval = T}
trp_rch = rch_200_cap %>%
  st_join(trap_poly) %>%
  filter(!is.na(trap_name))

trp_pts = capacity_pts %>%
  st_join(trap_poly) %>%
  filter(!is.na(trap_name)) %>%
  st_join(chnk_domain %>%
            st_buffer(dist = 500)) %>%
  filter(!is.na(Species)) %>%
  filter(trap_name %in% unique(trp_rch$trap_name))
 
comp_df = trp_pts %>%
  group_by(Trap = trap_name) %>%
  nest() %>%
  rename(pt_data = data) %>%
  left_join(trp_rch %>%
              group_by(Trap = trap_name) %>%
              nest() %>%
              rename(rch_data = data)) %>%
  left_join(chnk_domain %>%
              st_join(trap_poly) %>%
              filter(!is.na(trap_name)) %>%
              mutate(reach_leng = st_length(.)) %>%
              mutate_at(vars(reach_leng),
                        list(as.numeric)) %>%
              group_by(Trap = trap_name) %>%
              nest() %>%
              rename(old_domain = data)) %>%
  mutate(fig = map2(pt_data,
                    rch_data,
                    function(x, y) {
                      ggplot() +
                        geom_sf(data = x,
                                aes(color = chnk_per_m),
                                alpha = 0.6,
                                size = 3) +
                        geom_sf(data = y,
                                aes(color = chnk_per_m)) +
                        scale_color_viridis_c(direction = -1,
                                              name = 'Chnk / m') +
                        theme(axis.text = element_blank(),
                              axis.title = element_blank())
                    }),
         fig = map2(fig,
                    Trap,
                    function(x, y) {
                      x +
                        labs(title = y)
                    })) %>%
  arrange(Trap)

all_p = ggpubr::ggarrange(plotlist = comp_df$fig,
                          ncol = 2,
                          nrow = 2)

# ggsave('../output/figures/capacity_maps_all.pdf',
#        all_p,
#        width = 8,
#        height = 11)

# pdf('../output/figures/capacity_maps_all.pdf',
#        width = 8,
#        height = 11)
# for(i in 1:length(all_p)) print(all_p)
# dev.off()


# comp_df %>%
#   mutate(rch_cap = map_dbl(rch_data,
#                        .f = function(x) {
#                          x %>%
#                          summarise_at(vars(chnk_tot),
#                                       list(sum)) %>%
#                          pull(chnk_tot)
#                        })) %>%
#   mutate(pts_cap = map2_dbl(pt_data,
#                             old_domain,
#                             .f = function(x, y) {
#                               avg_cap = x %>%
#                                 summarise_at(vars(chnk_per_m),
#                                       list(mean),
#                                       na.rm = T) %>%
#                                 pull(chnk_per_m)
#                               strm_lgth = y %>%
#                                 summarise_at(vars(reach_leng),
#                                              list(sum),
#                                              na.rm = T) %>%
#                                 pull(reach_leng)
#                               avg_cap * strm_lgth
#                             }))
```

```{r add-extra-cap-upper-lemhi, eval = T}
# comp_df$rch_data[[which(comp_df$Trap == 'Upper Lemhi')]] %>% 
#   st_drop_geometry() %>%
#   group_by(GNIS_Name) %>%
#   summarise(n_rch = n_distinct(UniqueID),
#             avg_per_m = mean(chnk_per_m),
#             sd_per_m = sd(chnk_per_m, na.rm = T),
#             avg_cap = mean(chnk_tot),
#             sd_cap = sd(chnk_tot))

lem_strm_cap <- comp_df$pt_data[[which(comp_df$Trap == 'Upper Lemhi')]] %>% 
  group_by(StreamName) %>% 
  summarise_at(vars(chnk_per_m), 
               list(mean), 
               na.rm = T) %>% 
  st_drop_geometry()

lem_leng <- comp_df$old_domain[[which(comp_df$Trap == 'Upper Lemhi')]] %>% 
  group_by(StreamName) %>% 
  summarise_at(vars(reach_leng), 
               list(sum)) %>% 
  st_drop_geometry()

add_uplem_cap = lem_strm_cap %>% 
  full_join(lem_leng) %>% 
  filter(!is.na(reach_leng)) %>% 
  mutate(cap = chnk_per_m * reach_leng) %>% 
  filter(StreamName != "Lemhi River") %>% 
  summarise_at(vars(cap), 
               list(sum)) %>% 
  pull(cap)

qrf_caps$cap[qrf_caps$Trap == 'Upper Lemhi'] = qrf_caps$cap[qrf_caps$Trap == 'Upper Lemhi'] + add_uplem_cap

```



```{r}
library(FSA)
bh1 <- srFuns('BevertonHolt',
              param = 3)

data("spawn_recr_data")
# fit Beverton-Holt curve with capacity fixed at QRF capacity prediction
qrf_params = spawn_recr_data %>%
  group_by(Population) %>%
  nest() %>%
  left_join(qrf_caps %>%
              as_tibble() %>%
              select(Trap, cap, cap_se),
            by = c('Population' = 'Trap')) %>%
  filter(!is.na(cap)) %>%
  mutate(form = 'QRF',
         inits = map2(.x = data,
                      .y = cap,
                     .f = function(x, y) {
                       inits = srStarts(Parr ~ Spawners,
                                        data = x,
                                        type = 'BevertonHolt',
                                        param = 3)

                       inits$a = if_else(inits$a < 0, 
                                         2e-3, 
                                         inits$a)
                       inits$b = 1 / y
                       return(inits)
                       }),
         mod_fit = map2(.x = data,
                        .y = inits,
                        .f = function(x, y) {
                          fit = suppressWarnings(try(nls(log(Parr) ~ log(bh1(Spawners, a, b)),
                                                         data = x,
                                                         start = y,
                                                         algorithm = 'port',
                                                         lower = c(0, y['b']),
                                                         upper = c(Inf, y['b']))))
                        }),
         coefs = map(mod_fit,
                     .f = function(x) {
                       if(class(x) == 'try-error') {
                         return(as.numeric(NA))
                       } else coef(x)
                       }),
         preds = map2(.x = data,
                      .y = mod_fit,
                      .f = function(x, y) {
                        if(class(y) != 'try-error') {
                          tibble(Spawners = 1:max(x$Spawners)) %>%
                            mutate(Parr = predict(y,
                                                  newdata = .),
                                   Parr = exp(Parr))
                        } else return(tibble(Spawners = NA,
                                             Parr = NA))
                      })) %>%
  rename(est = cap,
         se = cap_se) %>%
  # select(-c(area:tot_length, tot_cap_cv)) %>%
  mutate(cv = se / est)

```

```{r}
data("spawn_rec_params")

spawn_rec_params %<>%
  bind_rows(qrf_params)

# pull out estimates of capacity
cap_tbl = spawn_rec_params %>%
  select(Population, form, est, se, cv) %>%
  arrange(Population, form)

# make a few estimates NA (too big)
cap_tbl %<>%
  mutate_at(vars(est, se, cv),
            list(~ if_else(Population %in% c('Entiat River',
                                             'Marsh Creek',
                                             'Minam River',
                                             'Tucannon River') &
                             form == 'BevertonHolt',
                           as.numeric(NA), .)))


# pull out fitted spawner recruit curves
curve_fits = spawn_rec_params %>%
  select(Population, form, preds) %>%
  unnest(cols = "preds") %>%
  arrange(Population, form)

# define polygons for uncertainty shading
plot_max = Inf
plot_max = 5e5
cap_poly = cap_tbl %>%
  mutate(lwrCI = est + se * qnorm(0.025),
         uprCI = est + se * qnorm(0.975)) %>%
  mutate(lwrCI = if_else(lwrCI < 0, 0, lwrCI),
         uprCI = if_else(uprCI > plot_max, plot_max, uprCI)) %>%
  left_join(spawn_rec_params %>%
              select(Population, data) %>%
              unnest(cols = "data") %>%
              group_by(Population) %>%
              summarise_at(vars(Spawners, Parr),
                           tibble::lst(min, max),
                           na.rm = T)) %>%
  group_by(Population, form) %>%
  summarise(coords = list(tibble(x = c(0, 0, Spawners_max, Spawners_max),
                                 y = c(lwrCI, uprCI, uprCI, lwrCI)))) %>%
  ungroup() %>%
  unnest(cols = c(coords))

# which watersheds to plot?
keep_wtsds = qrf_caps %>%
  filter(!is.na(cap)) %>%
  filter(!Trap %in% c('Methow R.')) %>%
  pull(Trap)

spawn_rec_comp_p = spawn_rec_params %>%
  # filter out a couple populations with super poor fits
  filter(Population %in% keep_wtsds) %>%
  select(Population, data) %>%
  unnest(cols = "data") %>%
  distinct() %>%
  ggplot(aes(x = Spawners,
             y = Parr)) +
  geom_polygon(data = cap_poly %>%
                 # filter out a couple populations with super poor fits
                 filter(Population %in% keep_wtsds),
              aes(x = x,
                  y = y,
                  fill = form),
              alpha = 0.2) +
  geom_line(data = curve_fits %>%
              # filter out a couple populations with super poor fits
              filter(Population %in% keep_wtsds),
            aes(color = form),
            lwd = 1.5) +
  geom_hline(data = cap_tbl %>%
               # filter out a couple populations with super poor fits
               filter(Population %in% keep_wtsds),
             aes(yintercept = est,
                 color = form),
             linetype = 2) +
  geom_point(aes(shape = Spawner_type),
             size = 3) +
  facet_wrap(~ Population,
             ncol = 3,
             scales = 'free') +
  scale_color_brewer(palette = 'Set1',
                     breaks = c('QRF',
                                'BevertonHolt',
                                'Ricker',
                                'Hockey'),
                     labels = c('QRF', 
                                'Beverton Holt',
                                'Ricker',
                                'Hockey Stick'),
                     name = 'Model') +
  scale_fill_brewer(palette = 'Set1',
                    breaks = c('QRF',
                               'BevertonHolt',
                               'Ricker',
                               'Hockey'),
                    labels = c('QRF', 
                               'Beverton Holt',
                               'Ricker',
                               'Hockey Stick'),
                    name = 'Model') +
  labs(shape = 'Spawner\nType') +
  theme(legend.position = "bottom")

dodge_width = 0.5
sr_est_comp_p = cap_tbl %>%
  filter(Population %in% keep_wtsds) %>%
  mutate(lwrCI = est + qnorm(0.025) * se,
         lwrCI = if_else(lwrCI <= 0, 1, lwrCI),
         uprCI = est + qnorm(0.975) * se,
         uprCI = if_else(uprCI > 1.3e6, 1.3e6, uprCI)) %>%
  mutate(type = if_else(form == 'QRF',
                        'QRF', 'S-R')) %>%
  ggplot(aes(x = Population,
             y = est,
             color = form,
             group = form)) +
  geom_errorbar(aes(ymin = lwrCI,
                    ymax = uprCI),
                position = position_dodge(width = dodge_width),
                width = 0) +
  geom_point(aes(shape = type),
             fill = 'white',
             size = 2,
             position = position_dodge(width = dodge_width)) +
  scale_shape_manual(values = c('QRF' = 19,
                                'S-R' = 21),
                     name = 'Type') + 
  scale_color_brewer(palette = 'Set1',
                     breaks = c('QRF',
                                'BevertonHolt',
                                'Ricker',
                                'Hockey'),
                     labels = c('QRF',
                                'Beverton Holt',
                                'Ricker',
                                'Hockey Stick'),
                     name = 'Model') +
  # scale_y_continuous(trans = 'log') +
  # theme(axis.text.x = element_text(angle = 90),
  #       axis.text.y = element_blank()) +
  theme(axis.text = element_blank(),
        legend.position = "bottom") +
  facet_wrap(~ Population,
             scales = 'free') +
  labs(y = 'Capacity Estimate',
       x = NULL)
```

```{r, eval = F}
cap_tbl_ci = cap_tbl %>%
  mutate(lwrCI = est + qnorm(0.025) * se,
         lwrCI = if_else(lwrCI <= 0, 1, lwrCI),
         uprCI = est + qnorm(0.975) * se,
         uprCI = if_else(uprCI > 1.3e6, 1.3e6, uprCI))

comp_df = cap_tbl_ci %>%
  filter(form != 'QRF') %>%
  filter(!is.na(est)) %>%
  inner_join(cap_tbl_ci %>%
               filter(form == 'QRF') %>%
               select(Population, form, est) %>%
               spread(form, est) %>%
               rename(qrf_est = QRF) %>%
               left_join(cap_tbl_ci %>%
                           filter(form == 'QRF') %>%
                           select(Population, form, lwrCI) %>%
                           spread(form, lwrCI) %>%
                           rename(qrf_lwrCI = QRF)) %>%
               left_join(cap_tbl_ci %>%
                           filter(form == 'QRF') %>%
                           select(Population, form, uprCI) %>%
                           spread(form, uprCI) %>%
                           rename(qrf_uprCI = QRF))) %>%
  mutate(in_qrf_ci = if_else(est <= qrf_uprCI & est >= qrf_lwrCI, T, F),
         qrf_in_ci = if_else(qrf_est <= uprCI & qrf_est >= lwrCI, T, F),
         overlap_ci = if_else(lwrCI <= qrf_uprCI & uprCI >= qrf_lwrCI, T, F))

comp_df %>%
  group_by(form) %>%
  summarise(n_pops = n_distinct(Population)) %>%
  full_join(comp_df %>%
              group_by(form) %>%
              summarise_at(vars(ends_with("_ci")),
                           list(sum),
                           na.rm = T)) %>%
  mutate_at(vars(perc_in_qrf_ci = in_qrf_ci,
                 perc_qrf_in_ci = qrf_in_ci,
                 perc_overlap_ci = overlap_ci),
            list(~ . / n_pops))


comp_df %>%
  filter(!overlap_ci)
```


We then plotted the data, as well as the fitted curves, including the one which uses QRF estimates of capacity as one of the parameters, on the same plot, to compare the various estimates.

```{r sr-curves, fig.height = 10, fig.cap = "Estimates of spawners and their offspring summer parr, with various spawner-recruit curves ploted. Dashed lines are the esimates of capacity for each curve. QRF curve is a Beverton-Holt curve with the capacity parameter fixed to the QRF estimate of capacity above the screw trap."}
spawn_rec_comp_p
```

```{r sr-comp-fig}
sr_est_comp_p
```
