---
title: "Summer Juvenile Fish"
author: "Kevin See^[Biomark Inc.]"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  rmarkdown::html_vignette:
    fig_caption: yes
    fig_height: 8
    fig_width: 8
    toc: yes
    toc_depth: 1
vignette: >
  %\VignetteIndexEntry{Summer_Juveniles}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
csl: /Users/kevin/Dropbox/Bibliography/StyleFiles/ecology.csl
bibliography:
- /Users/kevin/Dropbox/Bibliography/Research.bib
- /Users/kevin/Dropbox/Bibliography/SoftwareCitations.bib
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

library(pander)
# options for table formatting
panderOptions('big.mark', ',')
# panderOptions('digits', 3)
# panderOptions('round', 3)
panderOptions('keep.trailing.zeros', FALSE)
panderOptions('table.split.table', Inf)

library(captioner)
tab_nums = captioner(prefix = 'Table')
fig_nums = captioner()


# load packages for analysis
library(QRFcapacity)
library(tidyverse)
library(janitor)
library(magrittr)
library(minerva)
library(sf)
library(quantregForest)

# set default theme for ggplot
theme_set(theme_bw())
```

```{r}
# determine which set of fish/habitat data to use
data("fh_sum_dash_2014_17")
fish_hab = fh_sum_dash_2014_17 %>%
  mutate_at(vars(Watershed, Year),
            list(as.factor))

# data("fh_sum_champ_2017")
# fish_hab = fh_sum_champ_2017 %>%
#   mutate_at(vars(Watershed, Year),
#             list(as.factor))

# and the appropriate habitat dictionrary to go with it
# data("hab_dict_2017")
# hab_dict = hab_dict_2017

# all the related habitat data
data('champ_dash')
hab_data = champ_dash

# data("champ_site_2011_17")
# hab_data = champ_site_2011_17
# 
# data("champ_site_2011_17_avg")
# hab_avg = champ_site_2011_17_avg

```


# Introduction

# Data

The fish data was collected by various agencies during the summer low-flow season at many of the same sites surveyed using the CHaMP protocol. Survey methods included mark-recapture, three-pass removal sampling, two-pass removal sampling, and single-pass electrofishing, as well as snorkeling. We estimated juvenile fish abundance (and density) at all sites where fish survey data were available. Three-pass removal estimates used the Carle-Strub estimator (@Carle1978), following advice from @Hedger2013. Two-pass removal estimates used the estimator described by @Seber2002. Mark-recapture estimates used Chapmanâ€™s modified Lincoln-Peterson estimator (@Chapman1951) and were deemed valid if they met the criteria described in @Robson1964. These estimates were made using the `removal` and `mrClosed` functions from the FSA package (@Ogle2017) in R software (@Rsoftware2015). Snorkel counts were transformed to abundance estimates using paired snorkel-electrofishing sites to calibrate snorkel counts. 

Many sites were sampled in multiple years. To avoid any chance of pseudo-replication (since habitat data is not usually expected to vary much year-to-year), for any site with multiple surveys, we chose the survey with the highest estimated density. We used this criteria because we are interested in estimating carrying capacity, so using the highest observed density seemed appropriate.

***All sites fell within the range of steelhead, but many of them were outside the range of spring/summer Chinook salmon. However, defining the range of sp/su Chinook is tricky, and it is unclear if the reported data for Chinook salmon includes only sites considered with the range of Chinook, or if we should exclude data from some sites based on our best understanding of the species' range. Currently, we are using all data.***

```{r, eval = F}
library(maptools)

data("chnk_domain")

# which sites were sampled for Chinook? 
chnk_samps = fish_hab %>%
  filter(Species == 'Chinook') %>%
  select(Site:Lon, N) %>%
  distinct() %>%
  st_as_sf(coords = c('Lon', 'Lat'),
           crs = 4326) %>%
  st_transform(st_crs(chnk_domain))

# set snap distance (in meters)
st_crs(chnk_samps)
snap_dist = 1000

# which of those sites are in Chinook domain?
chnk_sites = chnk_samps %>%
  as_Spatial() %>%
  maptools::snapPointsToLines(chnk_domain %>%
                                mutate(id = 1:n()) %>%
                                select(id, MPG) %>%
                                as_Spatial(),
                              maxDist = snap_dist,
                              withAttrs = T,
                              idField = 'id') %>%
  as('sf') %>%
  select(-nearest_line_id, -snap_dist) %>%
  # include some sites in the John Day where Chinook were found (or seemed to be close to sites where Chinook were found)
  rbind(st_read('data/raw/domain/Chnk_JohnDay_TrueObs.shp') %>%
          st_transform(st_crs(chnk_domain)) %>%
          select(-in_range))

# ggplot() +
#   geom_sf(data = chnk_samps,
#           aes(color = 'Sampled')) +
#   geom_sf(data = chnk_sites,
#           aes(color = 'In Chnk Range')) +
#   theme(axis.text = element_blank())

fish_hab %<>%
  filter(Species == 'Steelhead' |
           (Species == 'Chinook' & Site %in% chnk_sites$Site))
```

After matching up the fish abundances with sites where we have habitat data, we are left with the following number of sites.

```{r}
fish_hab %>%
  xtabs(~ Watershed + Species + Year, .) %>%
  addmargins(margin = c(1, 3)) %>%
  pander()
```

```{r}
fish_hab %>%
  tabyl(Watershed, Year, Species) %>%
  adorn_totals(c('row', 'col')) %>%
  adorn_percentages('col') %>%
  adorn_pct_formatting(digits = 0,
                       rounding = 'half up') %>%
  adorn_ns %>%
  adorn_title %>%
  knitr::kable()

```

# Selecting Covariates

A key step in developing a QRF model to predict fish capacities is selecting the habitat covariates to include in the model. Random forest models naturally incorporate interactions between correlated covariates, which is essential since nearly all habitat variables are considered correlated to one degree or another. However, we aimed to avoid overly redundant variables (i.e., variables that measure similar aspects of the habitat). Further, including too many covariates can result in overfitting of the model (e.g., including as many covariates as data points).

## Methods

We used the Maximal Information-Based Nonparametric Exploration (MINE) class of statistics (@Reshef2011) to determine those habitat characteristics (covariates) most highly associated with observed parr densities. We calculated the maximal information coefficient (MIC), using the R package `minerva` (@Albanese2013), to measure the strength of the linear or non-linear association between two variables (@Reshef2011). The MIC value between each of the measured habitat characteristics and the response variable, juvenile fish density (fish/m), was used to inform decisions on which habitat covariates to include in the QRF parr capacity model.
	Habitat metrics were first grouped into broad categories that included channel unit, complexity, cover, disturbance, riparian, size, substrate, temperature, water quality, and woody debris. Within each category, metrics were ranked according to their MIC value (Figure 1). Our strategy was to select one or two variables with the highest MIC score within each category so that covariates describe different aspects of rearing habitat (e.g., substrate, temperature, etc.). 

```{r MINE_stats}

# # what are some possible habitat covariates?
# poss_hab_mets = hab_dict %>%
#   filter(MetricCategory != 'Categorical') %>%
#   filter(ShortName %in% names(fish_hab)) %>%
#   pull(ShortName)

# pull from which CHaMP metrics could be generated from DASH
poss_hab_mets = read_csv('data/hab_dict_champ_dash.csv') %>%
  select(-starts_with('X')) %>%
  filter(DASH_gen) %>%
  filter(MetricCategory != 'Categorical') %>%
  pull(ShortName) %>%
  unique()
poss_hab_mets = c(poss_hab_mets, 'aug_avg_temp', 'avg_aug_temp')

mine_res = fish_hab %>%
  split(list(.$Species)) %>%
  map_df(.id = 'Species',
         .f = function(x) {
           x %>%
             mutate(fish_dens = log(fish_dens + 0.005)) %>%
             estimate_MIC(covars = poss_hab_mets,
                          response = 'fish_dens')
         }) %>%
  left_join(hab_dict %>%
              filter(MetricGroupName == 'Visit Metric') %>%
              select(Metric = ShortName,
                     MetricCategory,
                     Name),
            by = 'Metric') %>%
  # put the metric names in descending order by MIC
  mutate_at(vars(Metric, Name),
            list(~ fct_reorder(., .x = MIC))) %>%
  select(Species, MetricCategory, Metric, everything()) %>%
  arrange(Species, MetricCategory, desc(MIC))

mine_plot_df = mine_res #%>%
  # filter out some metrics with too many NAs or 0s
  # filter((perc_NA < 0.2 & non_0 > 100) | MetricCategory == 'Temperature') #%>%
  # # filter out metrics with very low variance
  # filter(var < 0.1) %>% select(1:11)
  # # filter out area and volume metrics
  # filter(!grepl('Area', Metric),
  #        !grepl('Vol', Metric),
  #        Metric != 'Lgth_Wet')
```

```{r hab_mets_correlation}

library(corrr)
#----------------------------------------------
# Look at correlations between habitat metrics
#----------------------------------------------
# top metrics
sel_mets = poss_hab_mets
sel_mets = mine_plot_df %>%
  group_by(MetricCategory) %>%
  slice(1:5) %>%
  ungroup() %>%
  pull(Metric) %>%
  unique() %>%
  as.character()


corr_mat = hab_avg %>%
  select(one_of(sel_mets)) %>%
  corrr::correlate()

corr_mat %>%
  rearrange(absolute = F) %>%
  shave(upper = T) %>% 
  stretch() %>%
  filter(!is.na(r)) %>%
  filter(abs(r) > 0.5)

corr_mat %>%
  # rearrange(absolute = F) %>%
  shave(upper = T) %>% 
  rplot(legend = T,
        print_cor = T)

network_plot(corr_mat)
  
```


## Results

```{r mine_plot}
# make a plot of MIC values for all species
mine_p = mine_plot_df %>%
  ggplot(aes(x = Name,
             y = MIC,
             fill = Species)) +
  geom_col(position = position_dodge(1)) +
  coord_flip() +
  facet_wrap(~ MetricCategory,
             scales = 'free_y',
             ncol = 3) +
  scale_fill_brewer(palette = 'Set1',
                    guide = guide_legend(nrow = 1)) +
  theme(legend.position = 'bottom',
        axis.text = element_text(size = 5))

mine_p

```

```{r}
mine_p2 = mine_plot_df %>%
  ggplot(aes(x = Name,
             y = MIC,
             fill = Species)) +
  geom_col(position = position_dodge(1)) +
  coord_flip() +
  scale_fill_brewer(palette = 'Set1',
                    guide = guide_legend(nrow = 1)) +
  theme(legend.position = 'bottom',
        axis.text = element_text(size = 5))

mine_p2
```

In the end, we decided to use the same metrics for both species, and chose the following metrics:

```{r}
sel_hab_mets = crossing(Species = c('Chinook', 
                                    'Steelhead'),
                        Metric = c('CU_Freq',
                                   'DpthThlwg_UF_CV',
                                   'WetWDRat_Avg',
                                   'FishCovTotal',
                                   'DistPrin1',
                                   'RipCovGrnd',
                                   'DpthThlwg_Avg',
                                   'SubEstGrvl',
                                   'SubD50',
                                   'SubLT6',
                                   'AvgHourly',
                                   'Max7dAM',
                                   'Cond',
                                   'LWFreq_Wet'))


sel_hab_mets = crossing(Species = c('Chinook', 
                                    'Steelhead'),
                        Metric = poss_hab_mets)

sel_hab_mets = crossing(Species = c('Chinook', 
                                    'Steelhead'),
                        Metric = c('UcutArea_Pct',
                                   'FishCovNone',
                                   'SubEstGrvl',
                                   'FstTurb_Freq',
                                   'FstNT_Freq',
                                   'CU_Freq',
                                   'SlowWater_Pct',
                                   'NatPrin1',
                                   'DistPrin1',
                                   'avg_aug_temp',
                                   'Sin_CL',
                                   'WetWdth_CV',
                                   'WetBraid',
                                   'WetSC_Pct',
                                   'Discharge',
                                   'WetWdth_Int',
                                   'LWFreq_Wet',
                                   'LWVol_WetFstTurb'))


```


# Fit QRF Models

## Methods

Random forest models cannot handle missing data by default, so the first step is to impute any missing data. In order to limit the amount of imputation necessary, we first delete any observation with too many missing values, and then impute the rest. 

```{r impute_qrf_data}
qrf_mod_df = fish_hab %>%
  split(list(.$Species)) %>%
  map_df(.id = 'Species',
         .f = function(x) {
    spp = unique(x$Species)
    
    covars = sel_hab_mets %>%
      filter(Species == spp) %>%
      pull(Metric)
    
    data = impute_missing_data(data = x %>%
                                 mutate_at(vars(Watershed, Year),
                                           list(fct_drop)),
                               covars = covars,
                               impute_vars = c('Watershed', 'Elev_M', 'Sin', 'Year', 'CUMDRAINAG'),
                               method = 'missForest') %>%
      select(Site, Watershed, Year, LON_DD, LAT_DD, fish_dens, VisitID, one_of(covars))
    
    return(data)

  })

```

```{r fit_qrf_model}
# set the density offset (to accommodate 0z)
dens_offset = 0.005

qrf_mods = qrf_mod_df %>%
  split(list(.$Species)) %>%
  map(.f = function(z) {
    
    covars = sel_hab_mets %>%
      filter(Species == unique(z$Species)) %>%
      pull(Metric)
    
    set.seed(3)
    qrf_mod = quantregForest(x = z %>%
                               select(one_of(covars)) %>%
                               as.matrix,
                             y = z %>%
                               mutate_at(vars(fish_dens),
                                         list(~ log(. + dens_offset))) %>%
                               select(fish_dens) %>%
                               as.matrix(),
                             keep.inbag = T,
                             ntree = 1000)
    
    return(qrf_mod)
  })

```

```{r relative_importance plot}

rel_imp_p = qrf_mods %>%
  map(.f = function(x) {
    as_tibble(x$importance,
              rownames = 'Metric') %>%
      mutate(relImp = IncNodePurity / max(IncNodePurity)) %>%
      left_join(hab_dict %>%
                  select(Metric = ShortName,
                         Name)) %>%
      mutate_at(vars(Metric, Name),
                list(~ fct_reorder(., relImp))) %>%
      arrange(Metric) %>%
      distinct() %>%
      ggplot(aes(x = Name,
                 y = relImp)) +
      geom_col(fill = 'gray40') +
      coord_flip() +
      labs(x = 'Metric',
           y = 'Relative Importance')
      
  })

ggpubr::ggarrange(plotlist = rel_imp_p,
                  nrow = 1,
                  ncol = 2,
                  labels = names(qrf_mods))

```

```{r partial_dependence_plots}

plot_partial_dependence(qrf_mods[[1]],
                        qrf_mod_df %>%
                          filter(Species == 'Chinook'),
                        hab_dict,
                        scales = 'free_x')


plot_partial_dependence(qrf_mods[[2]],
                        qrf_mod_df %>%
                          filter(Species == 'Steelhead'),
                        hab_dict,
                        scales = 'free_x')


```


# Predict at Habitat Sites

```{r}

wtsd = "Lemhi"
wtsd = 'Upper Grande Ronde'
wtsd = c('Upper Grande Ronde', 'Minam')
# wtsd = 'John Day'
qrf_mod_df %>%
  filter(Species == 'Chinook',
         Watershed %in% wtsd) %>%
  left_join(champ_dash %>%
              filter(Watershed %in% wtsd) %>%
              group_by(Site, StreamName) %>%
              summarise_at(vars(Lgth_Wet, Area_Wet),
                           list(mean))) %>%
  mutate(pred_cap = predict(qrf_mods[[1]],
                            newdata = select(., one_of(unique(sel_hab_mets$Metric))),
                            what = 0.9)) %>%
  mutate(pred_cap = exp(pred_cap) - 0.005,
         pred_cap = pred_cap * Lgth_Wet / Area_Wet) %>%
  st_as_sf(coords = c('LON_DD', 'LAT_DD'),
           crs = 4326) %>%
  st_transform(crs = 5070) %>%
  ggplot() +
  geom_sf(aes(color = pred_cap)) +
  scale_color_viridis_c(direction = -1) +
  theme(axis.text = element_blank()) +
  labs(color = expression(Parr / m^2),
       title = paste(wtsd, collapse = ' '))

```



## Methods

## Results

# Extrapolation to Other Sites


# References